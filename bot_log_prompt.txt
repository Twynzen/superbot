A VER ESTE ES EL PROYECTO ENTIENDELO MUY BIEN ANTES DE CUALQUIER COSA:

El proyecto se divide en estas carpetas
API: Tiene 3 archivos aun en desarrollo esta sección: 

bot_controller.py:
from modules.resource_management import search_resources
from modules.combat import searchMob
from modules.characters_tracking import track_and_click_character
# ...otros imports necesarios...

def execute_action(action):
    if action == 'collect_resources':
        search_resources()
    elif action == 'search_mob':
        searchMob()
    # ... otros casos
    elif action == 'track_character':
        track_and_click_character()
    # ... más acciones a futuro
    else:
        print("Acción no reconocida.")

def interpret_and_execute_gpt_response(gpt_response):
    # Aquí vendría la lógica para interpretar la respuesta de la API
    # y convertirlo en una acción.
    action = parse_gpt_response_to_action(gpt_response)
    execute_action(action)

def parse_gpt_response_to_action(gpt_response):
    # Esta función se encargará de traducir la respuesta de GPT en una acción
    # Por ejemplo, si GPT sugiere recolectar recursos, devolvería 'collect_resources'
    # ...
    return action 


-game_api.py
-language_model.py

mapLocation: tiene algunas carpetas que se crean para obtener imagenes del mapa
combat_check_imagesguarda unas imagenes last_debug_image.png, last_reference_image.png
también tiene una imagen que dice combbat_debug.png y tiene una referencia que solo aparece en modo combate y la usaba para validar si estábamos en modo combate o no.
también tiene otra imagen llamada map_coordinates.png puede que esta sea una imagen que guardamos para ver las coordinadas del mapa.

modules:
Modules tiene estos archivos.py:
chat_management.py: por ahora vacio,
combat.py:import pyautogui as pg
import time
from modules.navigation import change_map
from modules.image_processing import capture_screenshot, image_difference
from config import COMBAT_MODE_REGION, DIRECTION_PATH_ABSTRUB_ZAAP,  MAP_LOCATION_DIR, WAIT_TIME
from modules.image_processing import capture_map_coordinates


def check_combat_status():
    """Revisa de manera indefinida si el bot está en combate, comparando capturas de pantalla con una imagen de referencia."""
    reference_image_path = 'ojoIA/combat_indicator.PNG'
    debug_image_path = f"{MAP_LOCATION_DIR}/combat_debug.png"

    while True:
        capture_screenshot(COMBAT_MODE_REGION, 'combat_debug.png', MAP_LOCATION_DIR)
        # Compara la imagen de depuración con la imagen de referencia.
        if not image_difference(debug_image_path, reference_image_path):
            print("Combat is still active...")
            time.sleep(3)  # Revisa cada 3 segundos
        else:
            print("Combat status check indicates combat has ended.")
            break
        
def searchMob():
     print("Comenzando ruta de abstrub para ardilla.")
            # Aquí iría la lógica para buscar mobs en la zona.
     coordinates_before_change = capture_map_coordinates()
     print(f"Coordenadas antes de cambiar de mapa: {coordinates_before_change}")

     change_map(DIRECTION_PATH_ABSTRUB_ZAAP)
     time.sleep(WAIT_TIME)  # Espera después de intentar cambiar de mapa.

     coordinates_after_change = capture_map_coordinates()
     print(f"Coordenadas después de intentar cambiar de mapa: {coordinates_after_change}")

     if coordinates_before_change == coordinates_after_change:
         print("No se detectaron cambios en la posición del mapa. Verificando modo de combate...")
         check_combat_status()  # Verifica continuamente si está en combate
     else:
         print("El cambio de mapa fue exitoso.")
            # Ejemplo: find_mobs()


//////////////
characters_tracking.py:

import os
import cv2
import pyautogui as pg

CHARACTER_IMAGES_DIR = os.path.join("ojoIA", "characters", "main_character", "Static")

def load_character_templates():
    templates = {}
    for filename in os.listdir(CHARACTER_IMAGES_DIR):
        path = os.path.join(CHARACTER_IMAGES_DIR, filename)
        template = cv2.imread(path, cv2.IMREAD_COLOR)
        direction = os.path.splitext(filename)[0]  # 'look_down', 'look_up', etc.
        templates[direction] = template
    return templates

def detect_character(frame, templates):
    match_threshold = 0.8  # Ejemplo de umbral, debería ser ajustado según las pruebas
    for direction, template in templates.items():
        result = cv2.matchTemplate(frame, template, cv2.TM_CCOEFF_NORMED)
        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
        if max_val > match_threshold:
            top_left = max_loc
            h, w = template.shape[:2]
            bottom_right = (top_left[0] + w, top_left[1] + h)
            center = (top_left[0] + w // 2, top_left[1] + h // 2)
            cv2.rectangle(frame, top_left, bottom_right, color=(0, 255, 0), thickness=2)
            return center  # Devuelve la posición central del personaje
    return None

def click_on_character(center):
    if center is not None:
        pg.click(center)

//////////////

image_processing.py:import pytesseract
import os
import numpy as np
import cv2
import pyautogui as pg
from config import SCREENSHOTS_DIR, TESSERACT_CMD_PATH, MAP_LOCATION_DIR
from PIL import Image, ImageChops, UnidentifiedImageError



# Configura la ubicación de Tesseract en tu sistema
pytesseract.pytesseract.tesseract_cmd = TESSERACT_CMD_PATH


def capture_screenshot(region, filename, directory=SCREENSHOTS_DIR):
    """Toma una captura de pantalla de la región especificada y guarda la imagen en el directorio dado."""
    try:
        # Crea el directorio si no existe
        if not os.path.exists(directory):
            os.makedirs(directory)

        screenshot = pg.screenshot(region=region)
        screenshot_path = f"{directory}/{filename}"
        screenshot.save(screenshot_path)
        return screenshot_path
    except Exception as e:
        print(f"Error al capturar la pantalla: {e}")
        return None


def capture_map_coordinates():
    """Captura las coordenadas del mapa usando OCR."""
    try:
        region_to_capture = (0, 65, 100, 40)
        filename = "map_coordinates.png"
        screenshot_path = capture_screenshot(region_to_capture, filename, MAP_LOCATION_DIR)
        if screenshot_path:
            coordinates = process_image_for_text(screenshot_path)
            if coordinates.strip() == "":  # Verifica si Tesseract devolvió una cadena vacía.
                print("Tesseract no pudo detectar coordenadas en la imagen.")
                return "Unknown"  # Puedes devolver un valor que denote desconocido o error.
            return coordinates
        else:
            print("Fallo al capturar la imagen para OCR.")
            return "Capture Failed"
    except Exception as e:
        print(f"Error al capturar las coordenadas del mapa: {e}")
        return "Error"

def process_image_for_text(image_path):
    """Utiliza OCR para extraer texto de una imagen con configuraciones optimizadas."""
    try:
        image = Image.open(image_path)
        # Preprocesamiento de la imagen (opcional): puedes aplicar filtros para mejorar el contraste, convertir a escala de grises, etc.
        # ...
        # Configuraciones de Tesseract
        custom_config = r'--oem 3 --psm 6'
        return pytesseract.image_to_string(image, config=custom_config)
    except UnidentifiedImageError as e:
        print(f"No se pudo abrir la imagen: {e}")
        return None
    except Exception as e:
        print(f"Error al procesar la imagen para obtener texto: {e}")
        return None

def capture_and_process_image(region):
    """Combina la captura de pantalla y el procesamiento de OCR."""
    try:
        screenshot_path = capture_screenshot(region, 'temp.png')
        if screenshot_path:
            text = process_image_for_text(screenshot_path)
            return text
        return None
    except Exception as e:
        print(f"Error al capturar y procesar la imagen: {e}")
        return None

def get_image_difference(image1_path, image2_path):
    """Obtiene la diferencia entre dos imágenes."""
    try:
        img1 = Image.open(image1_path)
        img2 = Image.open(image2_path)
        return ImageChops.difference(img1, img2)
    except Exception as e:
        print(f"Error al obtener la diferencia entre imágenes: {e}")
        return None
    
def image_difference(image1_path, image2_path, save_debug=True):
    """Calcula la diferencia entre dos imágenes usando OpenCV y devuelve si son significativamente diferentes.
    Opcionalmente guarda las imágenes comparadas para depuración."""
    debug_dir = f"{MAP_LOCATION_DIR}/combat_check_images"  # Directorio para guardar imágenes de depuración
    if save_debug and not os.path.exists(debug_dir):
        os.makedirs(debug_dir)
    
    try:
        # Cargar imágenes y convertirlas a escala de grises
        img1 = cv2.imread(image1_path, cv2.IMREAD_GRAYSCALE)
        img2 = cv2.imread(image2_path, cv2.IMREAD_GRAYSCALE)

        # Calcular la diferencia entre las imágenes
        diff = cv2.absdiff(img1, img2)
        _, thresh = cv2.threshold(diff, 30, 255, cv2.THRESH_BINARY)

        # Guardar imágenes para depuración
        if save_debug:
            cv2.imwrite(os.path.join(debug_dir, 'last_reference_image.png'), img1)
            cv2.imwrite(os.path.join(debug_dir, 'last_debug_image.png'), img2)
            cv2.imwrite(os.path.join(debug_dir, 'diff_image.png'), thresh)  # Guardar imagen de diferencia para revisión

        # Comprobar si hay diferencias significativas
        if np.sum(thresh) > 0:  # Si hay píxeles blancos en la imagen umbralizada, hay diferencias
            print("Differences detected. Combat has ended or the scene has changed.")
            return True
        else:
            print("No differences found. Combat is still active.")
            return False
    except Exception as e:
        print(f"Error processing image difference using OpenCV: {e}")
        return True  # Si hay un error, suponer que el combate ha terminado por precaución

def capture_current_game_frame():
    """
    Captura la pantalla actual del juego y devuelve una imagen.
    La región capturada puede ser ajustada según la resolución y la ventana del juego.
    """
    game_region = (0, 0, 1920, 1080)  # Ajusta esta tupla a la región exacta del juego
    frame = pg.screenshot(region=game_region)
    frame = cv2.cvtColor(np.array(frame), cv2.COLOR_RGB2BGR)
    return frame
//////////////

navigation.py:
import pyautogui as pg
import time
from config import TOOLTIP_REGIONS, WAIT_TIME

CURRENT_DIRECTION_INDEX = 0

def change_map(path):
    global CURRENT_DIRECTION_INDEX
    direction_to_move = path[CURRENT_DIRECTION_INDEX]
    CURRENT_DIRECTION_INDEX = (CURRENT_DIRECTION_INDEX + 1) % len(path)
    
    # Mueve el cursor al botón de la dirección deseada y hace clic.
    pg.click(TOOLTIP_REGIONS[direction_to_move])
    time.sleep(WAIT_TIME)  # Espera después de clickear para dar tiempo al juego de cambiar el mapa.
    
    # Aquí podrías implementar lógica adicional si es necesario, como verificaciones después de cambiar el mapa.

//////////////
resource_management.py:
import pyautogui as pg
import time
from config import RESOURCE_PATHS, CONFIDENCE_LEVEL, WAIT_TIME

EXCEPTIONS = {
        'fresno': {
            'ignored_positions': [(1465, 862)],  # Lista de posiciones a ignorar
        },
        'trigo': {
            'special_click_offsets': [(907, 588, 4, 0)],  # (x, y, offset_x, offset_y) donde x, y es la posición a buscar y (offset_x, offset_y) es cuánto mover el mouse antes de clickear
        }
    }


def find_resource_on_screen(resource_type):
    """Busca los recursos en pantalla y devuelve la ubicación si los encuentra."""
    paths = RESOURCE_PATHS.get(resource_type, [])
    for path in paths:
        try:
            location = pg.locateCenterOnScreen(path, confidence=CONFIDENCE_LEVEL)
            if location:
                print(f"Recurso {resource_type} encontrado en {path}.")
                return location
        except pg.ImageNotFoundException:
            continue  # Simplemente continúa con la siguiente imagen
        except Exception as e:
            print(f"Error al buscar el recurso {resource_type} en {path}: {e}")
    # Si termina el bucle y no encuentra nada, imprime un mensaje general.
    print(f"Recurso {resource_type} no encontrado.")
    return None


def apply_exceptions(resource_type, location):
    """Aplica las excepciones de clic especificadas en el diccionario EXCEPTIONS."""
    if resource_type in EXCEPTIONS:
        resource_exceptions = EXCEPTIONS[resource_type]
        print(f"Aplicando excepciones para {resource_type}, posición encontrada: {location}")

        # Para el caso de trigo que necesita un clic especial
        if 'special_click_offsets' in resource_exceptions:
            for (x, y, offset_x, offset_y) in resource_exceptions['special_click_offsets']:
                if (location.x, location.y) == (x, y):
                    new_location = (location.x + offset_x, location.y + offset_y)
                    print(f"Aplicando offset especial a {resource_type}: {new_location}")
                    return new_location

        # Para el caso de fresno ignorado
        if 'ignored_positions' in resource_exceptions:
            for ignored_pos in resource_exceptions['ignored_positions']:
                if (location.x, location.y) == ignored_pos:
                    print(f"Ignorando posición de {resource_type} en {ignored_pos}")
                    return None

        # Para el caso de salvia que necesita ajustar el clic
        if 'click_adjustments' in resource_exceptions:
            for (offset_x, offset_y) in resource_exceptions['click_adjustments']:
                new_location = (location.x + offset_x, location.y + offset_y)
                print(f"Aplicando ajuste de clic a {resource_type}: {new_location}")
                return new_location

    return (location.x, location.y)
def collect_resource(resource_type):
    """Intenta recolectar un recurso dado si se encuentra en pantalla."""
    location = find_resource_on_screen(resource_type)
    if location:
        # Aplica las excepciones antes de hacer clic.
        new_location = apply_exceptions(resource_type, location)
        if new_location:
            pg.click(new_location)
            time.sleep(WAIT_TIME)
            print(f"Recolectado {resource_type}.")
            return True
        else:
            print(f"Recurso {resource_type} ignorado debido a una excepción.")
    return False

def search_and_collect_resources():
    """Bucle principal para buscar y recolectar recursos repetidamente hasta que no encuentre más."""
    while True:
        resources_found = False
        for resource_type in RESOURCE_PATHS.keys():
            while collect_resource(resource_type):  # Continúa intentando recolectar mientras haya recursos.
                resources_found = True
                print(f"Recolectado {resource_type}. Volviendo a buscar {resource_type}...")
        
        if not resources_found:
            print("No se encontraron más recursos. Intentando cambiar de mapa...")
            break  # Si en una pasada completa no se encuentra ningún recurso, rompe el bucle.

//////////////
ojoIAtiene resources, donde extraemos las imagenes de los recursos para que con las librerias comparemos y demos click de estar en la Lista
y otras imagenes como
combat_indicator.pngcombat_status.indicator.PNG

ojolA
│
├───characters
│   │
│   └───main_character
│       │
│       └───Static
│             ├─ look_down.png (17 KB)
│             ├─ look_down_left.png (10.4 KB)
│             ├─ look_down_right.png
│             ├─ look_left.png
│             ├─ look_right.png
│             ├─ look_up.png
│             ├─ look_up_left.png
│             └─ look_up_right.png
│
└───resources
    │
    ├───cereals
    │
    ├───herbage
    │
    ├───minerals
    │
    └───wood

//////////////
una carpeta llamda test, con  unos archivos vacios de py
test_combat.py
test_image_processing.py
test_navigation.py

//////////////

Una carpeta llamada utils que tiene

file_managment.py:
import os
from config import MAP_LOCATION_DIR

def save_data_to_file(data, filename):
    """Guarda datos en un archivo específico."""
    with open(os.path.join(MAP_LOCATION_DIR, filename), 'w') as file:
        # Aquí iría la lógica para escribir datos en el archivo.
        pass

def read_data_from_file(filename):
    """Lee datos de un archivo."""
    with open(os.path.join(MAP_LOCATION_DIR, filename), 'r') as file:
        # Aquí iría la lógica para leer datos del archivo.
        pass
y los otros vacios:
helpers.py y logger.py
//////////////

al final tenemos el config.py:
import pytesseract
# Configuración de la ruta de Tesseract-OCR
TESSERACT_CMD_PATH = r'C:\Program Files\Tesseract-OCR\tesseract.exe'
pytesseract.pytesseract.tesseract_cmd = TESSERACT_CMD_PATH

# Directorios para el manejo de recursos e imágenes
MAP_LOCATION_DIR = "mapLocation"
SCREENSHOTS_DIR = "ojoIA"
RESOURCES_DIR = "resources"
RESOURCES_TYPE =  {
    "trigo": "cereals",
    "castano": "wood",
    "fresno": "wood",
    "nogal": "wood",
    "hierro": "minerals",
    "ortiga": "herbage",
    "salvia": "herbage"
}
#region
REGION_TO_CAPTURE = (0, 65, 100 , 90-50) 



# Configuraciones de imágenes y navegación
IMAGE_OFFSET = 25
WAIT_TIME = 6
SCREENSHOT_SIZE = 100
DIRECTIONS = [
    'right', 'right', 'up', 'up', 'right', 'up', 'up', 'right', 'down', 'down',
    'down', 'up', 'up', 'right', 'right', 'up', 'right', 'up', 'up', 'left',
    'up', 'right', 'up', 'left'
]

# Rutas a imágenes específicas de recursos
RESOURCE_PATHS = {
    "cereals": {
        "trigo": [
            "ojoIA/resources/cereals/trigo1.PNG",
            "ojoIA/resources/cereals/trigo2.PNG",
            "ojoIA/resources/cereals/trigo3.PNG",
            "ojoIA/resources/cereals/trigo4.PNG",
            "ojoIA/resources/cereals/trigo5.PNG"
        ]
    },
    "wood": {
        "castano": [
            "ojoIA/resources/wood/casta1.PNG",
            "ojoIA/resources/wood/casta2.PNG",
            "ojoIA/resources/wood/casta3.PNG",
            "ojoIA/resources/wood/casta4.PNG"
        ],
        "fresno": [
            "ojoIA/resources/wood/fresno1.PNG",
            "ojoIA/resources/wood/fresno2.PNG",
            "ojoIA/resources/wood/fresno3.PNG"
        ],
        "nogal": [
            "ojoIA/resources/wood/nogal1.PNG",
            "ojoIA/resources/wood/nogal2.PNG",
            "ojoIA/resources/wood/nogal3.PNG"
        ]
    },
    "minerals": {
        "hierro": [
            "ojoIA/resources/minerals/hierro1.PNG",
            "ojoIA/resources/minerals/hierro2.PNG",
            "ojoIA/resources/minerals/hierro3.PNG",
            "ojoIA/resources/minerals/hierro4.PNG",
            "ojoIA/resources/minerals/hierro5.PNG"
        ]
    },
    "herbage": {
        "ortiga": [
            "ojoIA/resources/herbage/ortiga1.PNG",
            "ojoIA/resources/herbage/ortiga2.PNG",
            "ojoIA/resources/herbage/ortiga3.PNG",
            "ojoIA/resources/herbage/ortiga4.PNG",
            "ojoIA/resources/herbage/ortiga5.PNG"
        ],
        "salvia": [
            "ojoIA/resources/herbage/salvia1.PNG",
            "ojoIA/resources/herbage/salvia2.PNG"
        ]
    }
}


# Regiones de captura de pantalla para detectar tooltips y otros indicadores
TOOLTIP_REGIONS = {
    'up': (960 - 50, 0, 100, 50),
    'left': (0 + 300, 540 - 25, 100, 50),
    'right': (1920 - 400, 540 - 25, 100, 50),
    'down': (960 - 50, 1080 - 200, 100, 50),
}
#Combat 
COMBAT_MODE_REGION = (1310, 995, 165, 45) 


CONFIDENCE_LEVEL = 0.7

/////////////////
Y el centro de todo
main.py :
from modules.combat import  searchMob
from modules.resource_management import search_resources
from modules.image_processing import capture_map_coordinates

def main_menu():
    print("Seleccione una opción:")
    print("1. Recolectar recursos")
    print("2. Buscar mobs en la zona (Funcionalidad en desarrollo)")
    print("3. Leer chat del juego (Funcionalidad en desarrollo)")
    print("3. Combate automatico (Funcionalidad en desarrollo)")
    
    choice = input("Introduce el número de la opción deseada: ")
    return choice


        

def main():
    print("Iniciando el bot...")
    initial_coordinates = capture_map_coordinates()
    if initial_coordinates:
        print(f"Coordenadas iniciales del mapa al iniciar: {initial_coordinates}")
    else:
        print("No se pudieron capturar las coordenadas iniciales del mapa.")
    
    while True:
        user_choice = main_menu()
        
        if user_choice == '1':
            while True:
                search_resources()
            

        elif user_choice == '2':
           while True:
               searchMob()
        
        elif user_choice == '3':
            print("Esta funcionalidad aún está en desarrollo.")
            # Aquí iría la lógica para leer el chat del juego.
            # Ejemplo: read_game_chat()
        
        elif user_choice == '4':
            print("Esta funcionalidad aún está en desarrollo.")
            # Aquí iría la lógica para combate
            # Ejemplo: read_game_chat() IR AL BANCO

        else:
            print("Opción no válida. Por favor, intenta de nuevo.")

if __name__ == "__main__":
    main()



